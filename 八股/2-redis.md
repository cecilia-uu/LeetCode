# 1. 使用场景

1. 你在最近的项目中的那些场景中使用了redis？
（目的）验证项目场景真实性，切入点
- 根据自己简历上的业务进行回答
- 缓存
- 分布式锁

## 缓存
### 穿透、击穿、雪崩
2. 如果发生了缓存穿透，该如何解决？
- 缓存穿透：查询一个不存在的数据，mysql因为一直查不到数据所以不会直接写入缓存中，就会导致每次请求都查数据库。一般来源于恶意攻击！
- 解决方案1：缓存空数据，查询返回的数据为空时，仍把这个空结果进行缓存。如 {key:1, value: null}
优点：简单
缺点：消耗内存，可能会发生不一致的问题
- 解决方案2: 加入boolean过滤器
优点：内存占用少，没有多余的key
缺点：实现复杂，存在误判

- 布隆过滤器（BloomFilter）：
bitmap(位图)：相当于是一个以bit位为单位的数组，数组中每个单元只能存储二进制数0/1
作用：用于检索一个元素是否在一个集合中
误判率：数组越小，误判率越大；数组越大，误判率越小，但是带来了更多的内存消耗。
实现方案：Redisson/Guava

3. 击穿
给某一个key设置了过期时间，当key过期时，恰好这个时间点，对这个key有了大量的并发请求，有可能会压垮DB。
- 解决方案1: 互斥锁
强一致性, 性能差
- 解决方案2: 逻辑过期
高可用，性能优, 不能保证数据绝对一致。

todo: 具体是啥样的？？？？

4. 雪崩
同一时间段，大量的缓存key同时失效/redis服务宕机，导致大量请求到达数据库，带来巨大压力。
解决方案：
- 给不同key的TTL添加随机值
- 利用redis集群提高服务的可用性。哨兵模式、集群模式
- 给缓存业务添加降级限流策略。ngxin/spring cloud gateway
降级可以作为系统的保底策略，适用于穿透、击穿、雪崩
- 给业务添加多级缓存 Guava/Caffeine

* 总结
穿透无中生有key,布隆过滤null隔离。
缓存击穿过期key,锁与非期解难题。
雪崩大量过期key,过期时间要随机。
面试必考三兄弟，可用限流来保底。

### 双写一致、持久化
5. redis作为缓存，mysql的数据如何与redis进行同步呢？（双写一致性）
* 定义：双写一致性：当修改了数据库的数据时同时也要更新缓存的数据，两者数据要一致。
1) 一定要设置前提，介绍自己的业务背景 （一致性要求高/允许延迟一致）
2) 两种答题方向
2.1 异步的方案
- 允许延时一致性的业务，采用异步通知
* 使用MQ中间件，更新数据后，通知缓存删除
* 利用Canal的异步通知，不需要修改业务代码，伪装为mysql的一个从节点，canal通过读取binlog数据更新缓存。（基于Canal的异步通知：监听mysql的binlog（二进制日志记录了所有DDL数据定义语言语句和DML数据操纵语言语句，但不包括数据查询语句））
* 异步通知保证数据的最终一致性。

2.2 强一致性，采用redisson提供的读写锁
- 共享锁：读锁readLock，加锁后，其他线程可以共享读操作
- 排他锁/独占锁：writeLock，加锁后，阻塞其他线程读写操作
- 强一致/性能低

3) 读操作：缓存命中，直接返回；未命中，继续查询DB，写入缓存，设置过期时间
4) 写操作：延迟双删
删除缓存 -> 修改数据库 -> （延迟） 删除缓存

6. 数据的持久化怎么做的？
1） RDB
全称redis database backup file（redis数据备份文件），也叫Redis数据快照。简单来说，就是把内存中的所有数据都记录到磁盘。当redis实例故障重启后，从磁盘读取快照文件，恢复数据。
```bash
save # 由redis主进程执行，会阻塞所有命令
bgsave # 开启子进程执行RDB，避免主进程受影响
```
* 执行原理？
bgsave开始的时候会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入RDB文件。
fork采用的是copy-on-write技术：
当主进程执行读操作的时候，访问共享内存
当主进程执行写操作的时候，会拷贝一份数据，执行写操作。

2）AOF
全称是Append Only File （追加文件）。redis处理的每一个写命令都会记录在AOF文件，可以看作是命令日志文件。
因为是记录命令，AOF文件比RDB文件大很多。而且AOF会对同一key进行多次写操作，但是只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少命令达到相同效果。

### 数据过期、淘汰策略
7. redis的key过期后，会立即删除吗？
* 惰性删除：设置该key过期时间后，我们不再管，当需要该key时，再检查是否过期。
优点：对CPU友好，只会在需要该key的时候才会检查
缺点：对内存不友好，如果一个key已经过期了，但是一直没用，会一直存在内存里，不释放
* 定期删除：每隔一段时间，我们就对一些key进行检查，删除里面过期的key （从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key）
两种模式：
1）SLOW：定时任务，执行频率默认为10hz，每次不超过25ms，以通过修改配置文件redis.conf的hz选项调整这个次数
2）FAST：频率不固定，但是两次间隔不低于2ms,每次耗时不超过1ms
优点：可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。定期删除也能有效释放过期键占用的内存。
缺点：难以确定删除操作的执行时长和频率
* 两个都用
## 分布式锁
### setnx\redisson
## 计数器

## 保存token
## 消息队列
## 延迟队列
09
# 2. 其他面试问题
## 集群
主从
哨兵
集群
## 事务
## redis为什么那么快？